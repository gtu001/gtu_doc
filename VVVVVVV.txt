package com.sap.quo.fspm.util;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.Scanner;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;

import com.sap.quo.fspm.service.impl.FSPMPolicyBenefitsLevel123Service;

/**
 * 提供 WebService Log 的壓縮與解壓縮工具。
 */
public class PcWebServiceLogUtil {

    private final static Logger logger = Logger.getLogger(FSPMPolicyBenefitsLevel123Service.class.getName());

    /**
     * 字串壓縮，壓縮後再以 Base64 加密。
     * 
     * @param text 要壓縮的字串。
     * @return 若 {text} 為空字串或壓縮失敗，則回傳原字串。
     */
    public static String compress(String text) {
        if (StringUtils.isBlank(text)) {
            return text;
        }

        // 壓縮結果
        byte[] resultBytes = null;

        try (ByteArrayOutputStream out = new ByteArrayOutputStream();
                GZIPOutputStream gzip = new GZIPOutputStream(out)) {
            gzip.write(text.getBytes());
            gzip.finish();
            resultBytes = out.toByteArray();
        } catch (IOException e) {
            logger.error(e.getMessage(), e);
            return text;
        }

        // 加密
        return Base64.getEncoder().encodeToString(resultBytes);
    }

    /**
     * 離線解壓縮工具。
     * 
     * @param args 需輸入檔案來源。
     */
    public static void main(String[] args) {
        System.out.print("Please input your file: ");

        Scanner scanner = new Scanner(System.in);
        String source = scanner.nextLine();
        scanner.close();

        new PcWebServiceLogUtil().uncompress(source);
    }

    /**
     * 解壓縮。
     * 
     * @param source 檔案來源。
     */
    private void uncompress(String source) {
        // 未輸入檔案來源
        if (StringUtils.isBlank(source)) {
            throw new NullPointerException("The input file can not be empty!");
        }

        try {
            String text = read(source);
            text = doUncompress(text);
            write(source, text);

            System.out.println("finish");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 讀取檔案內容。
     * 
     * @param source 檔案來源。
     * @return 讀取的字串。
     * @throws IOException 檔案不存在或讀取失敗則拋出錯誤。
     */
    private String read(String source) throws IOException {
        System.out.println("Reading...");

        // 讀取中的字串
        String line;
        // 讀取結果
        StringBuilder text = new StringBuilder();

        // 來源檔案
        File sourceFile = new File(source);
        if (!sourceFile.exists()) {
            throw new IOException("File not found: " + source);
        }

        // 讀取
        try (FileReader fr = new FileReader(sourceFile); BufferedReader br = new BufferedReader(fr)) {
            while ((line = br.readLine()) != null) {
                text.append(line);
            }
        } catch (IOException e) {
            throw e;
        }

        return text.toString();
    }

    /**
     * 執行解壓縮。
     * 
     * @param base64EncodeText 以 Base64 加密的字串。
     * @return 還原後的字串。
     * @throws IOException 解壓失敗則拋出錯誤。
     */
    private String doUncompress(String base64EncodeText) throws IOException {
        System.out.println("Uncompressing...");

        // 解壓結果
        String result = null;
        // 寫入的字串長度
        int len = -1;
        // 讀取的資料
        byte[] buffer = new byte[1024];
        // 解密後的資料
        byte[] compressd = Base64.getDecoder().decode(base64EncodeText);

        // 解壓縮
        try (ByteArrayOutputStream out = new ByteArrayOutputStream();
                ByteArrayInputStream in = new ByteArrayInputStream(compressd);
                GZIPInputStream gzip = new GZIPInputStream(in)) {
            while ((len = gzip.read(buffer)) != -1) {
                out.write(buffer, 0, len);
            }

            result = out.toString();
        } catch (IOException e) {
            throw e;
        }

        return result;
    }

    /**
     * 將字串另存新檔。
     * 
     * @param source 檔案來源。
     * @param text   要儲存的字串。
     * @throws IOException 儲存失敗則拋出錯誤。
     */
    private void write(String source, String text) throws IOException {
        System.out.println("Writing...");

        // 副檔名的位置
        int extIndex = source.lastIndexOf(".");
        // 新檔名的時間
        String now = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMddHHmmss"));

        // 新檔的路徑與名稱
        String target = extIndex > 0
                ? source.substring(0, extIndex) + "_" + now + source.substring(extIndex, source.length())
                : source + "_" + now + ".txt";

        // 存檔
        try (FileOutputStream fos = new FileOutputStream(target);
                OutputStreamWriter osw = new OutputStreamWriter(fos, "UTF-8");
                BufferedWriter fw = new BufferedWriter(osw)) {
            fw.append(text);
            fw.flush();

            System.out.println("Result File: " + target);
        } catch (IOException e) {
            throw e;
        }
    }
}
